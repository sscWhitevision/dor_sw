<?php return array (
  '30040e89f78d4ccb17fbb6bcff967a24' => 
  array (
    'criteria' => 
    array (
      'name' => 'updater',
    ),
    'object' => 
    array (
      'name' => 'updater',
      'path' => '{core_path}components/updater/',
      'assets_path' => '{assets_path}components/updater/',
    ),
  ),
  '89a6d3948176fb83dfa89982e707e9c9' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.debug',
    ),
    'object' => 
    array (
      'key' => 'updater.debug',
      'value' => '',
      'xtype' => 'combo-boolean',
      'namespace' => 'updater',
      'area' => '(8) Debug',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '973731b20329add30116d4e5b6cb1761' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.cache_expires_core',
    ),
    'object' => 
    array (
      'key' => 'updater.cache_expires_core',
      'value' => '86400',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(7) Cache',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  'c6bcaa663ee2fac563caa39997c458c3' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.cache_expires_packages',
    ),
    'object' => 
    array (
      'key' => 'updater.cache_expires_packages',
      'value' => '43200',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(7) Cache',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '3ad04b1cf31f2e4f87d578cebf69c7c0' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.github_timeout',
    ),
    'object' => 
    array (
      'key' => 'updater.github_timeout',
      'value' => '1500',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(7) Cache',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '0f80e9fa81f8e47f37270d70cb4de777' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.modxcom_timeout',
    ),
    'object' => 
    array (
      'key' => 'updater.modxcom_timeout',
      'value' => '1000',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(7) Cache',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  'ae76aec6aa670243aaaa1dd6df1511e8' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.last_version_crosschecked',
    ),
    'object' => 
    array (
      'key' => 'updater.last_version_crosschecked',
      'value' => '',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(7) Cache',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '26ec924e72b36431fab092784fd5e808' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.core_notifications_mail',
    ),
    'object' => 
    array (
      'key' => 'updater.core_notifications_mail',
      'value' => '',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(2) Notifications: Core',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '7981660efd481940de4c8e758c9b6715' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.send_core_notifications',
    ),
    'object' => 
    array (
      'key' => 'updater.send_core_notifications',
      'value' => '',
      'xtype' => 'combo-boolean',
      'namespace' => 'updater',
      'area' => '(2) Notifications: Core',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '343596134ee8b95aff6377e856627ef6' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.send_core_notifications_user',
    ),
    'object' => 
    array (
      'key' => 'updater.send_core_notifications_user',
      'value' => '',
      'xtype' => 'combo-boolean',
      'namespace' => 'updater',
      'area' => '(2) Notifications: Core',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  'becdf47d550800a8379d0a980cc458e9' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.package_notifications_mail',
    ),
    'object' => 
    array (
      'key' => 'updater.package_notifications_mail',
      'value' => '',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(3) Notifications: Packages',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  'd15ff48b2ebb73ae79b4f64a12b7575d' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.send_package_notifications',
    ),
    'object' => 
    array (
      'key' => 'updater.send_package_notifications',
      'value' => '',
      'xtype' => 'combo-boolean',
      'namespace' => 'updater',
      'area' => '(3) Notifications: Packages',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  'e665d25f02ea30d53c82de0887f7addc' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.send_package_notifications_user',
    ),
    'object' => 
    array (
      'key' => 'updater.send_package_notifications_user',
      'value' => '',
      'xtype' => 'combo-boolean',
      'namespace' => 'updater',
      'area' => '(3) Notifications: Packages',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  'ad7637ab6b13c7b44d2490ee303c749c' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.repeat_notifications_hours',
    ),
    'object' => 
    array (
      'key' => 'updater.repeat_notifications_hours',
      'value' => '72',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(1) Notifications: General',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '5b261eae89e61c03b1ba7811c3eeed5c' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.send_notification_hours',
    ),
    'object' => 
    array (
      'key' => 'updater.send_notification_hours',
      'value' => '8',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(1) Notifications: General',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  'b387d34e250ad0db2698dc152d302756' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.mail_format_html',
    ),
    'object' => 
    array (
      'key' => 'updater.mail_format_html',
      'value' => '',
      'xtype' => 'combo-boolean',
      'namespace' => 'updater',
      'area' => '(1) Notifications: General',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '59d63be8b79676509a82a5e994427d5d' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.check_core_release_level',
    ),
    'object' => 
    array (
      'key' => 'updater.check_core_release_level',
      'value' => '3',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(5) Check Levels',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  'dd445b75b2c2be683dc5d7f89471e811' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.check_core_version_level',
    ),
    'object' => 
    array (
      'key' => 'updater.check_core_version_level',
      'value' => '1',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(5) Check Levels',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '1243c9599adb0396e85d5902e4c08fba' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.send_version_digest_user',
    ),
    'object' => 
    array (
      'key' => 'updater.send_version_digest_user',
      'value' => '',
      'xtype' => 'combo-boolean',
      'namespace' => 'updater',
      'area' => '(4) Notifications Digest',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '184eebe2df8c4646bab65f63e6cf72fc' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.send_version_digest_hours',
    ),
    'object' => 
    array (
      'key' => 'updater.send_version_digest_hours',
      'value' => '720',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(4) Notifications Digest',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '44566b00c0b0c93a1d425231acb1e955' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.last_send_core_notification',
    ),
    'object' => 
    array (
      'key' => 'updater.last_send_core_notification',
      'value' => '',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(6) Persistance',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '8787e1f5af818dba79cc64fb1d011b86' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.last_send_package_notification',
    ),
    'object' => 
    array (
      'key' => 'updater.last_send_package_notification',
      'value' => '',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(6) Persistance',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  'a605a49a42572cf3949dabd903fa3dfe' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.last_send_version_digest',
    ),
    'object' => 
    array (
      'key' => 'updater.last_send_version_digest',
      'value' => '',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(6) Persistance',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '8ec1380e781ce04285ab15de5e924f2c' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.last_send_core',
    ),
    'object' => 
    array (
      'key' => 'updater.last_send_core',
      'value' => '',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(6) Persistance',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '696531e21330bddb6a7cb71c8a4b76f5' => 
  array (
    'criteria' => 
    array (
      'key' => 'updater.last_send_packages',
    ),
    'object' => 
    array (
      'key' => 'updater.last_send_packages',
      'value' => '',
      'xtype' => 'textfield',
      'namespace' => 'updater',
      'area' => '(6) Persistance',
      'editedon' => '0000-00-00 00:00:00',
    ),
  ),
  '7e2b01a75c25613608f85457fc946302' => 
  array (
    'criteria' => 
    array (
      'category' => 'Updater',
    ),
    'object' => 
    array (
      'id' => 4,
      'parent' => 0,
      'category' => 'Updater',
      'rank' => 0,
    ),
  ),
  '4dee8d2226c9ea85319edf0316153cfb' => 
  array (
    'criteria' => 
    array (
      'name' => 'Updater Notifier',
    ),
    'object' => 
    array (
      'id' => 3,
      'source' => 0,
      'property_preprocess' => 0,
      'name' => 'Updater Notifier',
      'description' => 'This plugin manages the notifications for updates.',
      'editor_type' => 0,
      'category' => 4,
      'cache_type' => 0,
      'plugincode' => '$eventName = $modx->event->name;

switch($eventName) {

    case \'OnUpdaterNotify\':
    case \'OnUpdaterNotifyCore\':
    case \'OnUpdaterNotifyPackages\':
        $pfx = "[Updater Notifier] ";

        /* set the keyed system setting to current time */
        if (!function_exists(\'resetTimedSetting\')) {
            function resetTimedSetting(&$modx, $key, $value = \'\') {
                $digestSetting = $modx->getObject(\'modSystemSetting\', $key);
                if (!is_null($digestSetting)) {
                    $digestSetting->set(\'value\', strtotime(\'now\'));
                    $digestSetting->save();
                    $cacheRefreshOptions = array(\'system_settings\' => array());
                    $modx->cacheManager->refresh($cacheRefreshOptions);
                }
                //$modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] set time key \'" . $key . "\': " . $modx->getOption($key, null, \'???\'));
                return;
            }
        }
        /* set the keyed system setting to current time */
        if (!function_exists(\'resetLastSendSetting\')) {
            function resetLastSendSetting($key, $value, &$modx) {
                $digestSetting = $modx->getObject(\'modSystemSetting\', $key);
                if (!is_null($digestSetting)) {
                    $digestSetting->set(\'value\', $value);
                    $digestSetting->save();
                    $cacheRefreshOptions = array(\'system_settings\' => array());
                    $modx->cacheManager->refresh($cacheRefreshOptions);
                }
                //$modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] set lastsend key \'" . $key . "\': " . $modx->getOption($key, null, \'???\'));
                return;
            }
        }

        /* save retrieve uncached option */
        if (!function_exists(\'getSafeOption\')) {
            function getSafeOption(&$modx, $key) {
                $setting = $modx->getObject(\'modSystemSetting\',$key);
                /*
                if (is_null($setting)) {
                    $modx->log(modX::LOG_LEVEL_WARN, "[Updater] null value returned for setting: ".$key." Does it exist?");
                }
                */
                return ($setting) ? $setting->get(\'value\') : "";
            }
        }

        $debug = getSafeOption($modx, \'updater.debug\');
        if (!$debug && $eventName=="OnWebPageComplete") {
            return;
        }

        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Updater request called");

        if (!$modx->loadClass(\'Updater\', MODX_CORE_PATH . \'components/updater/model/\', true, true)) {
            return;
        }
        $updater = new Updater($modx);

        /* this event works as a semi-functional cron simulator */
        /* it is fired for any web or manager request */
        /* now we need the most restrictive and quickest filter first */

        /* Send core notifications */
        $coreNotifications = getSafeOption($modx,\'updater.send_core_notifications\');
        if ( $coreNotifications === "1") {

            $timestamp = getSafeOption($modx, \'updater.last_send_core_notification\');

            $last_sendcore_json = getSafeOption($modx, \'updater.last_send_core\');
            if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} notify min every : " . $modx->getOption(\'updater.send_notification_hours\', null, 24) . " hours");

            if (isset($timestamp) && !is_null($timestamp)) {
                $elapsedHours = ((strtotime(\'now\') - $timestamp) / 3600);
                if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} elapsed hours since last core send check: " . round($elapsedHours, 2));

                /* check if time is over */
                if ($elapsedHours >= $modx->getOption(\'updater.send_notification_hours\', null, 24)) {
                    resetTimedSetting($modx, \'updater.last_send_core_notification\');


                    /* check if we need to refresh the core */
                    if ($updater->isCoreRefreshNeeded()) {
                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} need to refresh core data before sending email.");
                        $updater->refreshCoreVersion();
                        $updater->refreshCoreDownload();
                    }

                    /* check if the core is updateable */
                    if ( $updater->isCoreUpdateable() === true ) {

                        $last_send_core = $last_sendcore_json; //$modx->getOption(\'updater.last_send_core\', null, $updater->getCurrentCoreVersion());
                        $new_core = $updater->getLatestCoreVersion();

                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} last send: ".$last_send_core.", latest: ".$new_core);

                        if ( $debug || ( isset($last_send_core) && ($last_send_core==="" || $last_send_core!==$new_core))) {
                            resetLastSendSetting(\'updater.last_send_core\', $new_core, $modx);

                            if ($modx->getOption(\'updater.mail_format_html\', null, false) === "1") {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_coreinfo_html.tpl\');
                            } else {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_coreinfo.tpl\');
                            }

                            //$logodata = file_get_contents(MODX_MANAGER_PATH . \'templates/default/images/modx-icon-color.svg\');
                            $logodata = file_get_contents(MODX_ASSETS_PATH."components/updater/img/modx-icon-color.svg");
                            $placeholders = array(
                                \'logodata\' => base64_encode($logodata),
                                \'core_update\' => $new_core,
                                \'core_current\' => $updater->getCurrentCoreVersion(),
                                \'core_changelog_url\' => "https://github.com/modxcms/revolution/blob/master/core/docs/changelog.txt",
                                \'core_download_url\' => $updater->constructCoreDownloadUrl(),
                            );

                            $modx->setPlaceholders($placeholders);
                            $modx->getParser()->processElementTags(\'\', $chunk, true);

                            $subject = "Core update available for MODX site \'" . $modx->getOption(\'site_name\') . "\'";
                            $from = $modx->getOption(\'emailsender\',\'yourmodxsite\');
                            $fromName = "MODX System Notifier (Core)";

                            $time = microtime(true);
                            $modx->getService(\'mail\', \'mail.modPHPMailer\');

                            $modx->mail->set(modMail::MAIL_BODY, $chunk);
                            $modx->mail->set(modMail::MAIL_FROM, $from);
                            $modx->mail->set(modMail::MAIL_FROM_NAME, $fromName);
                            $modx->mail->set(modMail::MAIL_SUBJECT, $subject);


                            // TODO: walk through users here
                            $modx->mail->address(\'to\', $modx->getOption(\'updater.core_notifications_mail\'));
                            $modx->mail->setHTML($modx->getOption(\'updater.mail_format_html\', null, false) === "1");

                            if ($debug) $modx->log(4,$pfx." intermediate time for setting up core mail: ".round(microtime(true)-$time,2));

                            if (!$modx->mail->send()) {
                                $modx->log(modX::LOG_LEVEL_ERROR, "${pfx} An error occurred while trying to send the email: " . $modx->mail->mailer->ErrorInfo);
                            } else {
                                $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Successfully send core data to " . $modx->getOption(\'updater.core_notifications_mail\'));
                            }
                            if ($debug) $modx->log(4,$pfx." intermediate time for sending core mail: ".round(microtime(true)-$time,2));

                            $modx->mail->reset();
                            if ($debug) $modx->log(4,$pfx." final time for sending core mail: ".round(microtime(true)-$time,2));

                        } else {
                            if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} No need to send core data.");
                        }
                    }
                }
            }
        }


        /* Send package notifications */
        $packageNotifications = getSafeOption($modx,\'updater.send_package_notifications\');
        if ($packageNotifications==="1") {

            $timestamp = getSafeOption($modx,\'updater.last_send_package_notification\');

            $last_sendpackages_json = getSafeOption($modx, \'updater.last_send_packages\');
            // if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] notify min every : ".$modx->getOption(\'updater.send_notification_hours\',null,24)." hours");

            if (isset($timestamp) && !is_null($timestamp)) {
                $elapsedHours = ((strtotime(\'now\') - $timestamp) / 3600);
                // if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] elapsed hours since last check: ".round($elapsedHours,2));

                /* check if time is over */
                if ($elapsedHours >= $modx->getOption(\'updater.send_notification_hours\',null,24)) {
                    $time = microtime(true);

                    /*
                        until now this strange reformatting is necessary because package controller
                        returns nonsense and we did not touch it in updater class
                    */
                    $package_names_update = array();
                    $tmp = $updater->getPackagesUpdateList();
                    if (isset($tmp) && !is_null($tmp)) {
                        $packages_names_update  = array_map(
                            function($v) {
                                return ($v[0][\'name\']." > ".$v[0][\'signature\']);
                            }, $tmp
                        );
                    } else {
                        return;
                    }

                    $packages_names_install = array();
                    $tmp = $updater->getPackagesList();
                    if (isset($tmp) && !is_null($tmp)) {
                        $packages_names_install = array_map(
                            function ($v) {
                                return ($v[\'package_name\'] . ": " . $v[\'signature\']);
                            },
                            array_filter(
                                $tmp,
                                function ($v) {
                                    return $v[\'installed\'] == "";
                                }
                            )
                        );
                    }

                    if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages to install: ".json_encode($packages_names_install));
                    if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages to update: ".json_encode($packages_names_update));


                    if (sizeof($packages_names_install)+sizeof($packages_names_update) > 0) {
                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} there are updates to notify!");
                        resetTimedSetting($modx, \'updater.last_send_package_notification\');

                        $store_send_packages = array_merge(
                            array_map(
                                function($v) {
                                    return array( \'name\' => $v[0][\'name\'], \'installed\'=>$v[0][\'installed\'], \'update\' => $v[0][\'signature\']);
                                },
                                $updater->getPackagesUpdateList()
                            ),
                            array_map(
                                function($v) {
                                    return array( \'name\' => $v[\'name\'], \'installed\'=>\'previous\', \'update\' => $v[\'signature\']);
                                },
                                array_filter($updater->getPackagesList(), function($v) {  return $v[\'installed\']==""; })
                            )
                        );


                        if ($debug)  $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} data: ".json_encode($store_send_packages));
                        if ($debug)  $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages_names_update: ".json_encode($packages_names_update));
                        if ($debug)  $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages_names_install: ".json_encode($packages_names_install));

                        $logodata = file_get_contents(MODX_ASSETS_PATH."components/updater/img/modx-icon-color.svg");

                        $placeholders = array(
                            \'logodata\' => base64_encode($logodata),
                            \'logoformat\' => \'\',
                            \'updater.packages_names_install\' => \'\'.implode("\\n",$packages_names_install),
                            \'updater.packages_names_update\' => \'\'.implode("\\n",$packages_names_update),
                        );

                        $store_send_packages_json = json_encode(array_values($store_send_packages));

                        /* only send mail if the packages list differs from last send packages list */
                        if ($store_send_packages_json !== $last_sendpackages_json || $debug) {
                            resetLastSendSetting(\'updater.last_send_packages\', $store_send_packages_json, $modx);

                            if ($modx->getOption(\'updater.mail_format_html\',null,false)==="1") {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_packageinfo_html.tpl\');
                            } else {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_packageinfo.tpl\');
                            }

                            $modx->setPlaceholders($placeholders);
                            $modx->getParser()->processElementTags(\'\', $chunk, true);

                            $subject = "Package update notification for MODX site \'" . $modx->getOption(\'site_name\') . "\'";
                            $from = $modx->getOption(\'emailsender\',\'yourmodxsite\');
                            $fromName = "MODX System Notifier (Packages)";

                            $time=microtime(true);

                            $modx->getService(\'mail\', \'mail.modPHPMailer\');
                            $modx->mail->set(modMail::MAIL_BODY, $chunk);
                            $modx->mail->set(modMail::MAIL_FROM, $from);
                            $modx->mail->set(modMail::MAIL_FROM_NAME, $fromName);
                            $modx->mail->set(modMail::MAIL_SUBJECT, $subject);
                            // TODO: walk through users here
                            $modx->mail->address(\'to\', $modx->getOption(\'updater.package_notifications_mail\'));
                            $modx->mail->setHTML($modx->getOption(\'updater.mail_format_html\',null,false)==="1");

                            if (!$modx->mail->send()) {
                                $modx->log(modX::LOG_LEVEL_ERROR, "${pfx} An error occurred while trying to send the email: " . $modx->mail->mailer->ErrorInfo);
                            } else {
                                $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Successfully send package data to ".$modx->getOption(\'updater.package_notifications_mail\'));
                            }

                            $modx->mail->reset();
                            if ($debug) $modx->log(4,$pfx." time for sending packages mail: ".round(microtime(true)-$time,2));


                        } else {
                            if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} There are updates available, but this notification was already send: ".$store_send_packages_json);
                        }

                    }
                }
            } else {
                resetTimedSetting($modx, \'updater.last_send_package_notification\');
            }
        }

        /* Send digest */
        if ($modx->getOption(\'updater.send_version_digest_user\',null,false)==="1") {
            $timestamp = $modx->getOption(\'updater.last_send_version_digest\', null, \'\');
            if (isset($timestamp) && !is_null($timestamp)) {
                $elapsedHours = ((strtotime(\'now\') - $timestamp) / 3600);
                //$modx->log(modX::LOG_LEVEL_INFO, "[updater-notifier] time elapsed: " . $elapsedHours . " h");

                /* check if digest is over */
                if ($elapsedHours > $modx->getOption(\'updater.send_version_digest_hours\') || $debug) {
                    // reset the timestamp here to prevent multiple mails
                    resetTimedSetting($modx, \'updater.last_send_version_digest\');

                    if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} SEND DIGEST.");

                    $packageList = array();
                    $packageList = $updater->getPackagesList();

                    $coreMessage = "You are up to date with version " . $updater->getCurrentCoreVersion();
                    $coreMessageHTML = "<div style=\'color:green\'>" . $coreMessage . "</div>";
                    if ($updater->isCoreUpdateable()) {
                        $coreMessage = "An UPDATE to version " . $updater->getLatestCoreVersion() . " is available!";
                        $coreMessageHTML = "<div style=\'color:red\'>" . $coreMessage . "</div>";
                        $coreMessage = "*** " . $coreMessage . " ***";
                    }

                    $packages_list = str_pad(\'Package\', 32) . " | " . str_pad(\'Version signature\', 40) . " | " . "update?\\n";
                    $packages_list .= str_pad("", strlen($packages_list), \'-\') . "\\n";
                    $updates_list = $updater->getPackagesUpdateList();
                    $updates = 0;
                    $installed = 0;
                    foreach ($updater->getPackagesList() as $p) {
                        $packages_list .= str_pad($p[\'name\'], 32) . " | " . str_pad($p[\'signature\'], 40);
                        if ($p[\'updateable\'] === true) {
                            $packages_list .= " | UPDATE AVAILABLE TO " . $updates_list[$p[\'signature\']][0][\'version\'];

                            $updates++;
                        } else {
                            if ($p[\'installed\'] == "") {
                                $packages_list .= " | Installation pending";
                                $installed++;
                            } else {
                                $packages_list .= " |";
                            }
                        }
                        $packages_list .= "\\n";
                    }

                    $logodata = file_get_contents(MODX_ASSETS_PATH."components/updater/img/modx-icon-color.svg");
                    //$logodata = file_get_contents(MODX_MANAGER_PATH . \'templates/default/images/modx-icon-color.svg\');

                    $placeholders = array(
                        \'logodata\' => base64_encode($logodata),
                        \'core_message\' => $coreMessage,
                        \'packages_list\' => $packages_list,
                        //\'packages_updates\' => json_encode($updates_list),
                        \'update_core\' => ($updater->getLatestCoreVersion() !== $updater->getCurrentCoreVersion()) ? $updater->getLatestCoreVersion() : \'\',
                        \'installable\' => $installed,
                        \'updateable\' => $updates
                    );

                    $placeholders[\'packages_message\'] = "";
                    if ($updates > 0) {
                        $placeholders[\'updater.packages_message\'] = "" . $updates . " packages can be updated!!!\\n";
                    } else {
                        $placeholders[\'packages_message\'] = "All packages are up to date.\\n";
                    }
                    if ($installed > 0) {
                        $placeholders[\'packages_message\'] .= "" . $installed . " packages are not installed yet.";
                    }

                    // send the digest
                    //$message = $modx->getChunk(\'updater.mail_version_digest.tpl\', $placeholders);
                    $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_text.tpl\');
                    $modx->setPlaceholders($placeholders);
                    $modx->getParser()->processElementTags(\'\', $chunk, true);
                    $message = $chunk;

                    $subject = "System notification for MODX site \'" . $modx->getOption(\'site_name\') . "\'";
                    $from = $modx->getOption(\'emailsender\',\'yourmodxsite\');
                    $fromName = "MODX System Notifier";

                    $time=microtime(true);

                    $modx->getService(\'mail\', \'mail.modPHPMailer\');
                    $modx->mail->set(modMail::MAIL_BODY, $message);
                    $modx->mail->set(modMail::MAIL_FROM, $from);
                    $modx->mail->set(modMail::MAIL_FROM_NAME, $fromName);
                    $modx->mail->set(modMail::MAIL_SUBJECT, $subject);
                    // TODO: walk through users here
                    $modx->mail->address(\'to\', $modx->getOption(\'updater.core_notifications_mail\'));
                    $modx->mail->setHTML(false);

                    if (!$modx->mail->send()) {
                        $modx->log(modX::LOG_LEVEL_ERROR, "${pfx} An error occurred while trying to send the email: " . $modx->mail->mailer->ErrorInfo);
                    } else {
                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Successfully send digest to ".$modx->getOption(\'updater.core_notifications_mail\'));
                    }

                    $modx->mail->reset();
                    if ($debug) $modx->log(4,$pfx." time for sending digest mail: ".round(microtime(true)-$time,2));
                }
            } else {
                /* no timestamp in system settings? */
                if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} no time stamp in system settings found.");
                resetTimedSetting($modx, \'updater.last_send_version_digest\');
            }
        }
        break;

}
return;',
      'locked' => 0,
      'properties' => NULL,
      'disabled' => 0,
      'moduleguid' => '',
      'static' => 0,
      'static_file' => '',
      'content' => '$eventName = $modx->event->name;

switch($eventName) {

    case \'OnUpdaterNotify\':
    case \'OnUpdaterNotifyCore\':
    case \'OnUpdaterNotifyPackages\':
        $pfx = "[Updater Notifier] ";

        /* set the keyed system setting to current time */
        if (!function_exists(\'resetTimedSetting\')) {
            function resetTimedSetting(&$modx, $key, $value = \'\') {
                $digestSetting = $modx->getObject(\'modSystemSetting\', $key);
                if (!is_null($digestSetting)) {
                    $digestSetting->set(\'value\', strtotime(\'now\'));
                    $digestSetting->save();
                    $cacheRefreshOptions = array(\'system_settings\' => array());
                    $modx->cacheManager->refresh($cacheRefreshOptions);
                }
                //$modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] set time key \'" . $key . "\': " . $modx->getOption($key, null, \'???\'));
                return;
            }
        }
        /* set the keyed system setting to current time */
        if (!function_exists(\'resetLastSendSetting\')) {
            function resetLastSendSetting($key, $value, &$modx) {
                $digestSetting = $modx->getObject(\'modSystemSetting\', $key);
                if (!is_null($digestSetting)) {
                    $digestSetting->set(\'value\', $value);
                    $digestSetting->save();
                    $cacheRefreshOptions = array(\'system_settings\' => array());
                    $modx->cacheManager->refresh($cacheRefreshOptions);
                }
                //$modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] set lastsend key \'" . $key . "\': " . $modx->getOption($key, null, \'???\'));
                return;
            }
        }

        /* save retrieve uncached option */
        if (!function_exists(\'getSafeOption\')) {
            function getSafeOption(&$modx, $key) {
                $setting = $modx->getObject(\'modSystemSetting\',$key);
                /*
                if (is_null($setting)) {
                    $modx->log(modX::LOG_LEVEL_WARN, "[Updater] null value returned for setting: ".$key." Does it exist?");
                }
                */
                return ($setting) ? $setting->get(\'value\') : "";
            }
        }

        $debug = getSafeOption($modx, \'updater.debug\');
        if (!$debug && $eventName=="OnWebPageComplete") {
            return;
        }

        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Updater request called");

        if (!$modx->loadClass(\'Updater\', MODX_CORE_PATH . \'components/updater/model/\', true, true)) {
            return;
        }
        $updater = new Updater($modx);

        /* this event works as a semi-functional cron simulator */
        /* it is fired for any web or manager request */
        /* now we need the most restrictive and quickest filter first */

        /* Send core notifications */
        $coreNotifications = getSafeOption($modx,\'updater.send_core_notifications\');
        if ( $coreNotifications === "1") {

            $timestamp = getSafeOption($modx, \'updater.last_send_core_notification\');

            $last_sendcore_json = getSafeOption($modx, \'updater.last_send_core\');
            if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} notify min every : " . $modx->getOption(\'updater.send_notification_hours\', null, 24) . " hours");

            if (isset($timestamp) && !is_null($timestamp)) {
                $elapsedHours = ((strtotime(\'now\') - $timestamp) / 3600);
                if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} elapsed hours since last core send check: " . round($elapsedHours, 2));

                /* check if time is over */
                if ($elapsedHours >= $modx->getOption(\'updater.send_notification_hours\', null, 24)) {
                    resetTimedSetting($modx, \'updater.last_send_core_notification\');


                    /* check if we need to refresh the core */
                    if ($updater->isCoreRefreshNeeded()) {
                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} need to refresh core data before sending email.");
                        $updater->refreshCoreVersion();
                        $updater->refreshCoreDownload();
                    }

                    /* check if the core is updateable */
                    if ( $updater->isCoreUpdateable() === true ) {

                        $last_send_core = $last_sendcore_json; //$modx->getOption(\'updater.last_send_core\', null, $updater->getCurrentCoreVersion());
                        $new_core = $updater->getLatestCoreVersion();

                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} last send: ".$last_send_core.", latest: ".$new_core);

                        if ( $debug || ( isset($last_send_core) && ($last_send_core==="" || $last_send_core!==$new_core))) {
                            resetLastSendSetting(\'updater.last_send_core\', $new_core, $modx);

                            if ($modx->getOption(\'updater.mail_format_html\', null, false) === "1") {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_coreinfo_html.tpl\');
                            } else {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_coreinfo.tpl\');
                            }

                            //$logodata = file_get_contents(MODX_MANAGER_PATH . \'templates/default/images/modx-icon-color.svg\');
                            $logodata = file_get_contents(MODX_ASSETS_PATH."components/updater/img/modx-icon-color.svg");
                            $placeholders = array(
                                \'logodata\' => base64_encode($logodata),
                                \'core_update\' => $new_core,
                                \'core_current\' => $updater->getCurrentCoreVersion(),
                                \'core_changelog_url\' => "https://github.com/modxcms/revolution/blob/master/core/docs/changelog.txt",
                                \'core_download_url\' => $updater->constructCoreDownloadUrl(),
                            );

                            $modx->setPlaceholders($placeholders);
                            $modx->getParser()->processElementTags(\'\', $chunk, true);

                            $subject = "Core update available for MODX site \'" . $modx->getOption(\'site_name\') . "\'";
                            $from = $modx->getOption(\'emailsender\',\'yourmodxsite\');
                            $fromName = "MODX System Notifier (Core)";

                            $time = microtime(true);
                            $modx->getService(\'mail\', \'mail.modPHPMailer\');

                            $modx->mail->set(modMail::MAIL_BODY, $chunk);
                            $modx->mail->set(modMail::MAIL_FROM, $from);
                            $modx->mail->set(modMail::MAIL_FROM_NAME, $fromName);
                            $modx->mail->set(modMail::MAIL_SUBJECT, $subject);


                            // TODO: walk through users here
                            $modx->mail->address(\'to\', $modx->getOption(\'updater.core_notifications_mail\'));
                            $modx->mail->setHTML($modx->getOption(\'updater.mail_format_html\', null, false) === "1");

                            if ($debug) $modx->log(4,$pfx." intermediate time for setting up core mail: ".round(microtime(true)-$time,2));

                            if (!$modx->mail->send()) {
                                $modx->log(modX::LOG_LEVEL_ERROR, "${pfx} An error occurred while trying to send the email: " . $modx->mail->mailer->ErrorInfo);
                            } else {
                                $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Successfully send core data to " . $modx->getOption(\'updater.core_notifications_mail\'));
                            }
                            if ($debug) $modx->log(4,$pfx." intermediate time for sending core mail: ".round(microtime(true)-$time,2));

                            $modx->mail->reset();
                            if ($debug) $modx->log(4,$pfx." final time for sending core mail: ".round(microtime(true)-$time,2));

                        } else {
                            if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} No need to send core data.");
                        }
                    }
                }
            }
        }


        /* Send package notifications */
        $packageNotifications = getSafeOption($modx,\'updater.send_package_notifications\');
        if ($packageNotifications==="1") {

            $timestamp = getSafeOption($modx,\'updater.last_send_package_notification\');

            $last_sendpackages_json = getSafeOption($modx, \'updater.last_send_packages\');
            // if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] notify min every : ".$modx->getOption(\'updater.send_notification_hours\',null,24)." hours");

            if (isset($timestamp) && !is_null($timestamp)) {
                $elapsedHours = ((strtotime(\'now\') - $timestamp) / 3600);
                // if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "[updater-notifier] elapsed hours since last check: ".round($elapsedHours,2));

                /* check if time is over */
                if ($elapsedHours >= $modx->getOption(\'updater.send_notification_hours\',null,24)) {
                    $time = microtime(true);

                    /*
                        until now this strange reformatting is necessary because package controller
                        returns nonsense and we did not touch it in updater class
                    */
                    $package_names_update = array();
                    $tmp = $updater->getPackagesUpdateList();
                    if (isset($tmp) && !is_null($tmp)) {
                        $packages_names_update  = array_map(
                            function($v) {
                                return ($v[0][\'name\']." > ".$v[0][\'signature\']);
                            }, $tmp
                        );
                    } else {
                        return;
                    }

                    $packages_names_install = array();
                    $tmp = $updater->getPackagesList();
                    if (isset($tmp) && !is_null($tmp)) {
                        $packages_names_install = array_map(
                            function ($v) {
                                return ($v[\'package_name\'] . ": " . $v[\'signature\']);
                            },
                            array_filter(
                                $tmp,
                                function ($v) {
                                    return $v[\'installed\'] == "";
                                }
                            )
                        );
                    }

                    if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages to install: ".json_encode($packages_names_install));
                    if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages to update: ".json_encode($packages_names_update));


                    if (sizeof($packages_names_install)+sizeof($packages_names_update) > 0) {
                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} there are updates to notify!");
                        resetTimedSetting($modx, \'updater.last_send_package_notification\');

                        $store_send_packages = array_merge(
                            array_map(
                                function($v) {
                                    return array( \'name\' => $v[0][\'name\'], \'installed\'=>$v[0][\'installed\'], \'update\' => $v[0][\'signature\']);
                                },
                                $updater->getPackagesUpdateList()
                            ),
                            array_map(
                                function($v) {
                                    return array( \'name\' => $v[\'name\'], \'installed\'=>\'previous\', \'update\' => $v[\'signature\']);
                                },
                                array_filter($updater->getPackagesList(), function($v) {  return $v[\'installed\']==""; })
                            )
                        );


                        if ($debug)  $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} data: ".json_encode($store_send_packages));
                        if ($debug)  $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages_names_update: ".json_encode($packages_names_update));
                        if ($debug)  $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} packages_names_install: ".json_encode($packages_names_install));

                        $logodata = file_get_contents(MODX_ASSETS_PATH."components/updater/img/modx-icon-color.svg");

                        $placeholders = array(
                            \'logodata\' => base64_encode($logodata),
                            \'logoformat\' => \'\',
                            \'updater.packages_names_install\' => \'\'.implode("\\n",$packages_names_install),
                            \'updater.packages_names_update\' => \'\'.implode("\\n",$packages_names_update),
                        );

                        $store_send_packages_json = json_encode(array_values($store_send_packages));

                        /* only send mail if the packages list differs from last send packages list */
                        if ($store_send_packages_json !== $last_sendpackages_json || $debug) {
                            resetLastSendSetting(\'updater.last_send_packages\', $store_send_packages_json, $modx);

                            if ($modx->getOption(\'updater.mail_format_html\',null,false)==="1") {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_packageinfo_html.tpl\');
                            } else {
                                $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_packageinfo.tpl\');
                            }

                            $modx->setPlaceholders($placeholders);
                            $modx->getParser()->processElementTags(\'\', $chunk, true);

                            $subject = "Package update notification for MODX site \'" . $modx->getOption(\'site_name\') . "\'";
                            $from = $modx->getOption(\'emailsender\',\'yourmodxsite\');
                            $fromName = "MODX System Notifier (Packages)";

                            $time=microtime(true);

                            $modx->getService(\'mail\', \'mail.modPHPMailer\');
                            $modx->mail->set(modMail::MAIL_BODY, $chunk);
                            $modx->mail->set(modMail::MAIL_FROM, $from);
                            $modx->mail->set(modMail::MAIL_FROM_NAME, $fromName);
                            $modx->mail->set(modMail::MAIL_SUBJECT, $subject);
                            // TODO: walk through users here
                            $modx->mail->address(\'to\', $modx->getOption(\'updater.package_notifications_mail\'));
                            $modx->mail->setHTML($modx->getOption(\'updater.mail_format_html\',null,false)==="1");

                            if (!$modx->mail->send()) {
                                $modx->log(modX::LOG_LEVEL_ERROR, "${pfx} An error occurred while trying to send the email: " . $modx->mail->mailer->ErrorInfo);
                            } else {
                                $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Successfully send package data to ".$modx->getOption(\'updater.package_notifications_mail\'));
                            }

                            $modx->mail->reset();
                            if ($debug) $modx->log(4,$pfx." time for sending packages mail: ".round(microtime(true)-$time,2));


                        } else {
                            if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} There are updates available, but this notification was already send: ".$store_send_packages_json);
                        }

                    }
                }
            } else {
                resetTimedSetting($modx, \'updater.last_send_package_notification\');
            }
        }

        /* Send digest */
        if ($modx->getOption(\'updater.send_version_digest_user\',null,false)==="1") {
            $timestamp = $modx->getOption(\'updater.last_send_version_digest\', null, \'\');
            if (isset($timestamp) && !is_null($timestamp)) {
                $elapsedHours = ((strtotime(\'now\') - $timestamp) / 3600);
                //$modx->log(modX::LOG_LEVEL_INFO, "[updater-notifier] time elapsed: " . $elapsedHours . " h");

                /* check if digest is over */
                if ($elapsedHours > $modx->getOption(\'updater.send_version_digest_hours\') || $debug) {
                    // reset the timestamp here to prevent multiple mails
                    resetTimedSetting($modx, \'updater.last_send_version_digest\');

                    if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} SEND DIGEST.");

                    $packageList = array();
                    $packageList = $updater->getPackagesList();

                    $coreMessage = "You are up to date with version " . $updater->getCurrentCoreVersion();
                    $coreMessageHTML = "<div style=\'color:green\'>" . $coreMessage . "</div>";
                    if ($updater->isCoreUpdateable()) {
                        $coreMessage = "An UPDATE to version " . $updater->getLatestCoreVersion() . " is available!";
                        $coreMessageHTML = "<div style=\'color:red\'>" . $coreMessage . "</div>";
                        $coreMessage = "*** " . $coreMessage . " ***";
                    }

                    $packages_list = str_pad(\'Package\', 32) . " | " . str_pad(\'Version signature\', 40) . " | " . "update?\\n";
                    $packages_list .= str_pad("", strlen($packages_list), \'-\') . "\\n";
                    $updates_list = $updater->getPackagesUpdateList();
                    $updates = 0;
                    $installed = 0;
                    foreach ($updater->getPackagesList() as $p) {
                        $packages_list .= str_pad($p[\'name\'], 32) . " | " . str_pad($p[\'signature\'], 40);
                        if ($p[\'updateable\'] === true) {
                            $packages_list .= " | UPDATE AVAILABLE TO " . $updates_list[$p[\'signature\']][0][\'version\'];

                            $updates++;
                        } else {
                            if ($p[\'installed\'] == "") {
                                $packages_list .= " | Installation pending";
                                $installed++;
                            } else {
                                $packages_list .= " |";
                            }
                        }
                        $packages_list .= "\\n";
                    }

                    $logodata = file_get_contents(MODX_ASSETS_PATH."components/updater/img/modx-icon-color.svg");
                    //$logodata = file_get_contents(MODX_MANAGER_PATH . \'templates/default/images/modx-icon-color.svg\');

                    $placeholders = array(
                        \'logodata\' => base64_encode($logodata),
                        \'core_message\' => $coreMessage,
                        \'packages_list\' => $packages_list,
                        //\'packages_updates\' => json_encode($updates_list),
                        \'update_core\' => ($updater->getLatestCoreVersion() !== $updater->getCurrentCoreVersion()) ? $updater->getLatestCoreVersion() : \'\',
                        \'installable\' => $installed,
                        \'updateable\' => $updates
                    );

                    $placeholders[\'packages_message\'] = "";
                    if ($updates > 0) {
                        $placeholders[\'updater.packages_message\'] = "" . $updates . " packages can be updated!!!\\n";
                    } else {
                        $placeholders[\'packages_message\'] = "All packages are up to date.\\n";
                    }
                    if ($installed > 0) {
                        $placeholders[\'packages_message\'] .= "" . $installed . " packages are not installed yet.";
                    }

                    // send the digest
                    //$message = $modx->getChunk(\'updater.mail_version_digest.tpl\', $placeholders);
                    $chunk = file_get_contents(MODX_CORE_PATH . \'components/updater/elements/tpl/notification_mail_text.tpl\');
                    $modx->setPlaceholders($placeholders);
                    $modx->getParser()->processElementTags(\'\', $chunk, true);
                    $message = $chunk;

                    $subject = "System notification for MODX site \'" . $modx->getOption(\'site_name\') . "\'";
                    $from = $modx->getOption(\'emailsender\',\'yourmodxsite\');
                    $fromName = "MODX System Notifier";

                    $time=microtime(true);

                    $modx->getService(\'mail\', \'mail.modPHPMailer\');
                    $modx->mail->set(modMail::MAIL_BODY, $message);
                    $modx->mail->set(modMail::MAIL_FROM, $from);
                    $modx->mail->set(modMail::MAIL_FROM_NAME, $fromName);
                    $modx->mail->set(modMail::MAIL_SUBJECT, $subject);
                    // TODO: walk through users here
                    $modx->mail->address(\'to\', $modx->getOption(\'updater.core_notifications_mail\'));
                    $modx->mail->setHTML(false);

                    if (!$modx->mail->send()) {
                        $modx->log(modX::LOG_LEVEL_ERROR, "${pfx} An error occurred while trying to send the email: " . $modx->mail->mailer->ErrorInfo);
                    } else {
                        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} Successfully send digest to ".$modx->getOption(\'updater.core_notifications_mail\'));
                    }

                    $modx->mail->reset();
                    if ($debug) $modx->log(4,$pfx." time for sending digest mail: ".round(microtime(true)-$time,2));
                }
            } else {
                /* no timestamp in system settings? */
                if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "${pfx} no time stamp in system settings found.");
                resetTimedSetting($modx, \'updater.last_send_version_digest\');
            }
        }
        break;

}
return;',
    ),
  ),
  '5b61ed2530f9f44b7b088886c48b0eaf' => 
  array (
    'criteria' => 
    array (
      'pluginid' => 3,
      'event' => 'OnUpdaterNotify',
    ),
    'object' => 
    array (
      'pluginid' => 3,
      'event' => 'OnUpdaterNotify',
      'priority' => 0,
      'propertyset' => 0,
    ),
  ),
  '76ea6795b241936ed8207240d2315725' => 
  array (
    'criteria' => 
    array (
      'name' => 'Updater Cache Observer',
    ),
    'object' => 
    array (
      'id' => 4,
      'source' => 0,
      'property_preprocess' => 0,
      'name' => 'Updater Cache Observer',
      'description' => 'This plugin observes package changes and refreshes Updaters caches accordingly.',
      'editor_type' => 0,
      'category' => 4,
      'cache_type' => 0,
      'plugincode' => '$eventName = $modx->event->name;
switch($eventName) {

    case \'OnCacheUpdate\':

        /* only trigger a refresh if packages or system settings are changed */
        $packageKey = $modx->getOption(\'cache_packages_key\', null, \'packages\');
        $settingsKey = $modx->getOption(\'cache_system_settings_key\', null, \'system_settings\');

        if ( isset($results[ $settingsKey ]) && $results[$settingsKey]) {
            //$modx->log(modX::LOG_LEVEL_DEBUG, "[Updater] clearing internal caches.");
            //$modx->log(modX::LOG_LEVEL_WARN, "[Updater] " . print_r($results, true));

            //$modx->log(modX::LOG_LEVEL_DEBUG, "[Updater]  clear packages cache");
            $result1 = $modx->cacheManager->clean(array(xPDO::OPT_CACHE_KEY => \'updater-packages\'));

            //$modx->log(modX::LOG_LEVEL_DEBUG, "[Updater]  clear core cache");
            $result2 = $modx->cacheManager->clean(array(xPDO::OPT_CACHE_KEY => \'updater-core\'));

            if ($result1 && $result2) {
                //$modx->log(modX::LOG_LEVEL_INFO, "[Updater] successfully cleared Updaters\' internal caches due to changed system settings/cache clear");
            } else {
                $modx->log(modX::LOG_LEVEL_WARN, "[Updater] There was an error clearing Updaters\' internal caches.");
            }
            break;
        }

        if ( isset($results[ $packageKey ]) && $results[$packageKey]) {
            $modx->log(modX::LOG_LEVEL_INFO, "[Updater] packages have been changed, clearing updater cache.");
            $cacheOptions = array( xPDO::OPT_CACHE_KEY => \'updater-packages\' );
            $result = $modx->cacheManager->clean($cacheOptions);
            //$modx->log(modX::LOG_LEVEL_INFO, "[Updater] clean result: ".$result);
            $modx->log(modX::LOG_LEVEL_INFO, "[Updater] Successfully cleared updater cache after package change.");
        }

        break;

    default:
        break;
}
return;',
      'locked' => 0,
      'properties' => NULL,
      'disabled' => 0,
      'moduleguid' => '',
      'static' => 0,
      'static_file' => '',
      'content' => '$eventName = $modx->event->name;
switch($eventName) {

    case \'OnCacheUpdate\':

        /* only trigger a refresh if packages or system settings are changed */
        $packageKey = $modx->getOption(\'cache_packages_key\', null, \'packages\');
        $settingsKey = $modx->getOption(\'cache_system_settings_key\', null, \'system_settings\');

        if ( isset($results[ $settingsKey ]) && $results[$settingsKey]) {
            //$modx->log(modX::LOG_LEVEL_DEBUG, "[Updater] clearing internal caches.");
            //$modx->log(modX::LOG_LEVEL_WARN, "[Updater] " . print_r($results, true));

            //$modx->log(modX::LOG_LEVEL_DEBUG, "[Updater]  clear packages cache");
            $result1 = $modx->cacheManager->clean(array(xPDO::OPT_CACHE_KEY => \'updater-packages\'));

            //$modx->log(modX::LOG_LEVEL_DEBUG, "[Updater]  clear core cache");
            $result2 = $modx->cacheManager->clean(array(xPDO::OPT_CACHE_KEY => \'updater-core\'));

            if ($result1 && $result2) {
                //$modx->log(modX::LOG_LEVEL_INFO, "[Updater] successfully cleared Updaters\' internal caches due to changed system settings/cache clear");
            } else {
                $modx->log(modX::LOG_LEVEL_WARN, "[Updater] There was an error clearing Updaters\' internal caches.");
            }
            break;
        }

        if ( isset($results[ $packageKey ]) && $results[$packageKey]) {
            $modx->log(modX::LOG_LEVEL_INFO, "[Updater] packages have been changed, clearing updater cache.");
            $cacheOptions = array( xPDO::OPT_CACHE_KEY => \'updater-packages\' );
            $result = $modx->cacheManager->clean($cacheOptions);
            //$modx->log(modX::LOG_LEVEL_INFO, "[Updater] clean result: ".$result);
            $modx->log(modX::LOG_LEVEL_INFO, "[Updater] Successfully cleared updater cache after package change.");
        }

        break;

    default:
        break;
}
return;',
    ),
  ),
  '9aa53b872b6b1374111ddab5c062d74d' => 
  array (
    'criteria' => 
    array (
      'pluginid' => 4,
      'event' => 'OnCacheUpdate',
    ),
    'object' => 
    array (
      'pluginid' => 4,
      'event' => 'OnCacheUpdate',
      'priority' => 0,
      'propertyset' => 0,
    ),
  ),
  '1b90e581a7739f1f01d817e8fb711566' => 
  array (
    'criteria' => 
    array (
      'name' => 'Updater Cron',
    ),
    'object' => 
    array (
      'id' => 5,
      'source' => 0,
      'property_preprocess' => 0,
      'name' => 'Updater Cron',
      'description' => 'This plugin simulates a cronlike scheduler and is triggered by web and manager page requests.',
      'editor_type' => 0,
      'category' => 4,
      'cache_type' => 0,
      'plugincode' => '/*
    This plugin implements a simple but effective cron mechanism to refresh updaters data.

    How does it work?
        - cronlike schedule is triggered by a web page request
        - on the init of the request the plugin is triggered
        - the file modification time of an (empty) file is checked
            (this is done way faster than to check a modx option object, which is generally not intended to change frequently,
             measurement on the same machine: get system setting ~0.01s, filemtime ~0.0005s !!!)
        - if the last saved time compared to the current time is greater than a preset interval,
            the plugin injects a tiny javascript to the webpage
        - the javascript is called async and finally triggers the refresh of the (sometimes time-consuming) updater refresh

    Benefits:
        This way there is no measureable time gap for your webpage to be delivered (instead of directly refreshing the
        updater data), so visitors and your websites performance will not be affected, even if the updater task runs a long time
        or runs into a timeout.
        There is no need to setup a cronjob for this (which may not be possible due to the environment or the client using updater).

    Drawbacks:
        This only works if enough visitors with js enabled browser frequently visit your webpage. If you only have 1 hit per month,
        the updaters cache will be refreshed once per month as well, regardless of the interval. In this case
        it is a better idea to call the script /connectors/updater.cron.php with a cronjob instead.
*/

$eventName = $modx->event->name;
switch($eventName) {
    case "OnManagerPageInit":
    case "OnWebPageInit":
        $key = \'updater.lastcroninject\';

        //$t = microtime(true);
        $lastInjectTime = "";
        if (file_exists(MODX_CORE_PATH.\'cache/UPDATER_CRON\')) {
            $lastInjectTime = filemtime(MODX_CORE_PATH.\'cache/UPDATER_CRON\');
        }

        $currentTime = time();
        if (is_null($lastInjectTime) || $lastInjectTime == \'\') {
            $lastInjectTime = 0;
        }

        /*
         * Check if time interval is reached. The interval is hardcoded to prevent unneccessary option lookups again.
         * Current Interval: 3600 = 1 hour
         *
         * That does not necessarily mean, that every interval an update lookup is done. This only triggers
         * following up events, the event handlers themselves have cache times to stick to.
         * This interval only ensures, that at least every hour the followups are checked.
         */

        if (($currentTime - $lastInjectTime) >= 3600) {
            //$modx->log(modX::LOG_LEVEL_DEBUG, "[updater cron-plugin] elapsed seconds since last core refresh: " . ($currentTime - $lastInjectTime) ." - we need to refresh!");

            /* adjust the last saved time stamp */
            touch(MODX_CORE_PATH.\'cache/UPDATER_CRON\');

            /* inject javascript into web page */
            //$modx->log(4, "[updater cron-plugin] injecting cron script at time ".$currentTime);
            //$modx->regClientScript(MODX_ASSETS_URL . \'components/updater/js/updater.croninject.js\');

            /*
                using regClientScript is not the favoured way here: it adds a roundtrip and does not give the
                chance to call the script async!
                Instead we will inject our tiny script code here direcly!
                    - the code could be inlined here, but is not for future development
            */
            $script  = "<script type=\'text/javascript\'>";
            $script .= "var U=\'".MODX_CONNECTORS_URL."updater/updater.cron.php\';\\n";
            $script .= file_get_contents( MODX_ASSETS_PATH . \'components/updater/js/updater.croninject.js\');
            $script .= "</script>";

            $modx->regClientHTMLBlock($script);
        }
}
return;',
      'locked' => 0,
      'properties' => NULL,
      'disabled' => 0,
      'moduleguid' => '',
      'static' => 0,
      'static_file' => '',
      'content' => '/*
    This plugin implements a simple but effective cron mechanism to refresh updaters data.

    How does it work?
        - cronlike schedule is triggered by a web page request
        - on the init of the request the plugin is triggered
        - the file modification time of an (empty) file is checked
            (this is done way faster than to check a modx option object, which is generally not intended to change frequently,
             measurement on the same machine: get system setting ~0.01s, filemtime ~0.0005s !!!)
        - if the last saved time compared to the current time is greater than a preset interval,
            the plugin injects a tiny javascript to the webpage
        - the javascript is called async and finally triggers the refresh of the (sometimes time-consuming) updater refresh

    Benefits:
        This way there is no measureable time gap for your webpage to be delivered (instead of directly refreshing the
        updater data), so visitors and your websites performance will not be affected, even if the updater task runs a long time
        or runs into a timeout.
        There is no need to setup a cronjob for this (which may not be possible due to the environment or the client using updater).

    Drawbacks:
        This only works if enough visitors with js enabled browser frequently visit your webpage. If you only have 1 hit per month,
        the updaters cache will be refreshed once per month as well, regardless of the interval. In this case
        it is a better idea to call the script /connectors/updater.cron.php with a cronjob instead.
*/

$eventName = $modx->event->name;
switch($eventName) {
    case "OnManagerPageInit":
    case "OnWebPageInit":
        $key = \'updater.lastcroninject\';

        //$t = microtime(true);
        $lastInjectTime = "";
        if (file_exists(MODX_CORE_PATH.\'cache/UPDATER_CRON\')) {
            $lastInjectTime = filemtime(MODX_CORE_PATH.\'cache/UPDATER_CRON\');
        }

        $currentTime = time();
        if (is_null($lastInjectTime) || $lastInjectTime == \'\') {
            $lastInjectTime = 0;
        }

        /*
         * Check if time interval is reached. The interval is hardcoded to prevent unneccessary option lookups again.
         * Current Interval: 3600 = 1 hour
         *
         * That does not necessarily mean, that every interval an update lookup is done. This only triggers
         * following up events, the event handlers themselves have cache times to stick to.
         * This interval only ensures, that at least every hour the followups are checked.
         */

        if (($currentTime - $lastInjectTime) >= 3600) {
            //$modx->log(modX::LOG_LEVEL_DEBUG, "[updater cron-plugin] elapsed seconds since last core refresh: " . ($currentTime - $lastInjectTime) ." - we need to refresh!");

            /* adjust the last saved time stamp */
            touch(MODX_CORE_PATH.\'cache/UPDATER_CRON\');

            /* inject javascript into web page */
            //$modx->log(4, "[updater cron-plugin] injecting cron script at time ".$currentTime);
            //$modx->regClientScript(MODX_ASSETS_URL . \'components/updater/js/updater.croninject.js\');

            /*
                using regClientScript is not the favoured way here: it adds a roundtrip and does not give the
                chance to call the script async!
                Instead we will inject our tiny script code here direcly!
                    - the code could be inlined here, but is not for future development
            */
            $script  = "<script type=\'text/javascript\'>";
            $script .= "var U=\'".MODX_CONNECTORS_URL."updater/updater.cron.php\';\\n";
            $script .= file_get_contents( MODX_ASSETS_PATH . \'components/updater/js/updater.croninject.js\');
            $script .= "</script>";

            $modx->regClientHTMLBlock($script);
        }
}
return;',
    ),
  ),
  '208e9dc3b737205fe810253a67298d3f' => 
  array (
    'criteria' => 
    array (
      'pluginid' => 5,
      'event' => 'OnManagerPageInit',
    ),
    'object' => 
    array (
      'pluginid' => 5,
      'event' => 'OnManagerPageInit',
      'priority' => 0,
      'propertyset' => 0,
    ),
  ),
  '69c866bdf9099e1ec8cb7dd560e44ec4' => 
  array (
    'criteria' => 
    array (
      'pluginid' => 5,
      'event' => 'OnWebPageInit',
    ),
    'object' => 
    array (
      'pluginid' => 5,
      'event' => 'OnWebPageInit',
      'priority' => 0,
      'propertyset' => 0,
    ),
  ),
  '4200abc7fbadb720eeb7fc44e09afaec' => 
  array (
    'criteria' => 
    array (
      'name' => 'Updater Refresh',
    ),
    'object' => 
    array (
      'id' => 6,
      'source' => 0,
      'property_preprocess' => 0,
      'name' => 'Updater Refresh',
      'description' => 'This plugin handles refresh events triggered e.g. by the cron handler.',
      'editor_type' => 0,
      'category' => 4,
      'cache_type' => 0,
      'plugincode' => '$eventName = $modx->event->name;

switch($eventName) {
    case \'OnUpdaterCoreRefresh\':
    case \'OnUpdaterPackagesRefresh\':
        /* just get the updater object and refresh core and extras */
        /* flag to only refresh if caches are invalid! */

        $debug = $modx->getOption(\'updater.debug\', null, false);

        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "[Updater] refresh plugin was triggered.");

        /* try to get the Updater object */
        if (!$modx->loadClass(\'Updater\', MODX_CORE_PATH . \'components/updater/model/\', true, true)) {
            return;
        }

        /*
            instead of handling these events we can also add js triggers to our pages which
            call the refresh connector directly.
        */

        $updater = new Updater($modx, array());

        if ($eventName=="OnUpdaterCoreRefresh") {
            if ($updater->isCoreRefreshNeeded()) {
                $updater->refreshCoreVersion();
                $updater->refreshCoreDownload();
            }
        }
        if ($eventName=="OnUpdaterPackagesRefresh") {
            if ($updater->isPackageRefreshNeeded()) {
                $updater->refreshPackageData();
            }
        }
}

return;',
      'locked' => 0,
      'properties' => NULL,
      'disabled' => 0,
      'moduleguid' => '',
      'static' => 0,
      'static_file' => '',
      'content' => '$eventName = $modx->event->name;

switch($eventName) {
    case \'OnUpdaterCoreRefresh\':
    case \'OnUpdaterPackagesRefresh\':
        /* just get the updater object and refresh core and extras */
        /* flag to only refresh if caches are invalid! */

        $debug = $modx->getOption(\'updater.debug\', null, false);

        if ($debug) $modx->log(modX::LOG_LEVEL_DEBUG, "[Updater] refresh plugin was triggered.");

        /* try to get the Updater object */
        if (!$modx->loadClass(\'Updater\', MODX_CORE_PATH . \'components/updater/model/\', true, true)) {
            return;
        }

        /*
            instead of handling these events we can also add js triggers to our pages which
            call the refresh connector directly.
        */

        $updater = new Updater($modx, array());

        if ($eventName=="OnUpdaterCoreRefresh") {
            if ($updater->isCoreRefreshNeeded()) {
                $updater->refreshCoreVersion();
                $updater->refreshCoreDownload();
            }
        }
        if ($eventName=="OnUpdaterPackagesRefresh") {
            if ($updater->isPackageRefreshNeeded()) {
                $updater->refreshPackageData();
            }
        }
}

return;',
    ),
  ),
  '3059d97116b4c1f36be9b617641d7942' => 
  array (
    'criteria' => 
    array (
      'pluginid' => 6,
      'event' => 'OnUpdaterCoreRefresh',
    ),
    'object' => 
    array (
      'pluginid' => 6,
      'event' => 'OnUpdaterCoreRefresh',
      'priority' => 0,
      'propertyset' => 0,
    ),
  ),
  '49963271a6b77387b3172b0d3b874814' => 
  array (
    'criteria' => 
    array (
      'pluginid' => 6,
      'event' => 'OnUpdaterPackagesRefresh',
    ),
    'object' => 
    array (
      'pluginid' => 6,
      'event' => 'OnUpdaterPackagesRefresh',
      'priority' => 0,
      'propertyset' => 0,
    ),
  ),
);